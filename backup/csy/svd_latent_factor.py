# -*- coding: utf-8 -*-
"""SVD_Latent Factor

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TZkeCoubjiXLNWgtzKEy55PmoV7XtqGX

# SVD

## 1. Install & Import Packages
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import pandas as pd

import tensorflow as tf

import numpy as np
import matplotlib.pyplot as plt

import pprint

# %matplotlib inline
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable

import tensorflow as tf
# import tensorflow_recommenders as tfrs

from tensorflow.keras.losses import binary_crossentropy
from tensorflow.keras import backend as K
from tensorflow.keras.layers import Lambda, Input, Dense, Dropout
from tensorflow.keras.models import Model
from tensorflow.keras.callbacks import LambdaCallback, EarlyStopping, Callback
from tensorflow.keras.utils import plot_model
import glob

def get_path(filename):
  return f'drive/MyDrive/Colab Notebooks/Data/{filename}'

glob.glob("drive/MyDrive/Colab Notebooks/Data/*")

df_train = pd.read_json(get_path('train_all_meta_v2.json'))
df_test = pd.read_json(get_path('test_all_meta_v2.json'))

from scipy.sparse.linalg import svds

pivoted = df_train.pivot_table('rating_per_user', 'userID', 'wine_id', aggfunc='max')

df_pivot = pivoted.fillna(0)
df_pivot

matrix = df_pivot.values
user_ratings_mean = np.mean(matrix, axis = 1)
# R_user_mean : 사용자-와인에 대해 사용자 평균 평점을 뺀 것.
matrix_tag_mean = matrix - user_ratings_mean.reshape(-1, 1)

matrix_tag_mean.shape

matrix_tag_mean

U, sigma, Vt = svds(matrix_tag_mean, k = 12)

print(U.shape)
print(sigma.shape)
print(Vt.shape)

sigma = np.diag(sigma)

sigma[0]

# U, Sigma, Vt의 내적을 수행하면, 다시 원본 행렬로 복원이 된다. 
# 거기에 + 사용자 평균 rating을 적용한다. 
svd_user_predicted_ratings = np.dot(np.dot(U, sigma), Vt) + user_ratings_mean.reshape(-1, 1)

df_svd_preds = pd.DataFrame(svd_user_predicted_ratings, columns = df_pivot.columns)
df_svd_preds.head()

df_pivot.index

df_svd_preds.index = df_pivot.index

df_svd_preds

from tqdm.notebook import tqdm

hit = 0
total = 0
results = []
for user_id in tqdm(df_svd_preds.index):
  predictions = df_svd_preds.loc[user_id, :].sort_values(ascending=False).head(500).index.values
  trues = df_test.loc[(df_test.userID == user_id) & (df_test.like == 1),'wine_id'].values
  correct = np.intersect1d(predictions, trues)
  total += trues.shape[0]
  hit += correct.shape[0]
  results.append((trues.shape[0], correct.shape[0]))

df_result = pd.DataFrame(results, columns=['trues', 'hit'])

df_result['recall'] = df_result.hit / df_result.trues
df_result['precision'] = df_result.hit / 500

hit, total, hit/total

df_result.mean()

df_result





"""## 2. ROC 구하기 (like)"""

df_pivot = df_train.pivot_table('like', 'userID', 'wine_id', aggfunc='max').fillna(0)

matrix = df_pivot.values
user_ratings_mean = np.mean(matrix, axis = 1)
# R_user_mean : 사용자-와인에 대해 사용자 평균 평점을 뺀 것.
matrix_tag_mean = matrix - user_ratings_mean.reshape(-1, 1)

U, sigma, Vt = svds(matrix_tag_mean, k = 12)
sigma = np.diag(sigma)

# U, Sigma, Vt의 내적을 수행하면, 다시 원본 행렬로 복원이 된다. 
# 거기에 + 사용자 평균 rating을 적용한다. 
svd_user_predicted_ratings = np.dot(np.dot(U, sigma), Vt) + user_ratings_mean.reshape(-1, 1)

df_svd_preds = pd.DataFrame(svd_user_predicted_ratings, columns = df_pivot.columns)
df_svd_preds.head()

df_svd_preds.index = df_pivot.index

from tqdm.notebook import tqdm

df_svd_preds.loc[1201,:].sort_values(ascending=False)

from sklearn.metrics import roc_auc_score
from sklearn.metrics import classification_report

def get_result(model):
  y_pred = model.predict(cached_test).flatten()
  y_pred_class = [1 if pred > 0.5 else 0 for pred in y_pred]

  print(f"ROC: {roc_auc_score(y_true, y_pred)}")
  print(classification_report(y_true, y_pred_class))

df_test[['userID', 'wine_id','like']]

predictions = [] 
for user_id, wine_id in zip(df_test.userID, df_test.wine_id):
  try:
    predictions.append(df_svd_preds.loc[user_id, wine_id])
  except:
    predictions.append(None)

df_test['prediction'] = predictions

df_test2 = df_test[['like', 'prediction']]

df_test2 = df_test2.dropna().reset_index(drop=True)

df_test2

df_test2

from sklearn.metrics import roc_auc_score
from sklearn.metrics import classification_report

# def get_result(model):
#   y_pred = model.predict(cached_test).flatten()
#   y_pred_class = [1 if pred > 0.5 else 0 for pred in y_pred]

#   print(f"ROC: {roc_auc_score(y_true, y_pred)}")
#   print(classification_report(y_true, y_pred_class))

roc_auc_score(df_test2.like, df_test2.prediction)

